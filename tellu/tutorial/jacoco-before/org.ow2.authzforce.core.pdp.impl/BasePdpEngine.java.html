<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="no"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BasePdpEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.ow2.authzforce:authzforce-ce-core-pdp-engine</a> &gt; <a href="index.source.html" class="el_package">org.ow2.authzforce.core.pdp.impl</a> &gt; <span class="el_source">BasePdpEngine.java</span></div><h1>BasePdpEngine.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2012-2019 THALES.
 *
 * This file is part of AuthzForce CE.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.ow2.authzforce.core.pdp.impl;

import java.io.IOException;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;

import javax.xml.datatype.XMLGregorianCalendar;

import org.ow2.authzforce.core.pdp.api.AttributeFqn;
import org.ow2.authzforce.core.pdp.api.AttributeFqns;
import org.ow2.authzforce.core.pdp.api.AttributeSources;
import org.ow2.authzforce.core.pdp.api.CloseablePdpEngine;
import org.ow2.authzforce.core.pdp.api.DecisionCache;
import org.ow2.authzforce.core.pdp.api.DecisionRequest;
import org.ow2.authzforce.core.pdp.api.DecisionRequestBuilder;
import org.ow2.authzforce.core.pdp.api.DecisionResult;
import org.ow2.authzforce.core.pdp.api.EvaluationContext;
import org.ow2.authzforce.core.pdp.api.HashCollections;
import org.ow2.authzforce.core.pdp.api.ImmutableDecisionRequest;
import org.ow2.authzforce.core.pdp.api.IndeterminateEvaluationException;
import org.ow2.authzforce.core.pdp.api.expression.ExpressionFactory;
import org.ow2.authzforce.core.pdp.api.policy.PrimaryPolicyMetadata;
import org.ow2.authzforce.core.pdp.api.policy.RootPolicyProvider;
import org.ow2.authzforce.core.pdp.api.value.AttributeBag;
import org.ow2.authzforce.core.pdp.api.value.Bag;
import org.ow2.authzforce.core.pdp.api.value.Bags;
import org.ow2.authzforce.core.pdp.api.value.DateTimeValue;
import org.ow2.authzforce.core.pdp.api.value.DateValue;
import org.ow2.authzforce.core.pdp.api.value.StandardDatatypes;
import org.ow2.authzforce.core.pdp.api.value.TimeValue;
import org.ow2.authzforce.core.pdp.impl.policy.RootPolicyEvaluator;
import org.ow2.authzforce.core.pdp.impl.policy.RootPolicyEvaluators;
import org.ow2.authzforce.core.xmlns.pdp.StandardEnvironmentAttributeSource;
import org.ow2.authzforce.xacml.identifiers.XacmlStatusCode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Preconditions;

import net.sf.saxon.s9api.XdmNode;

/**
 * This is the core XACML PDP engine implementation.
 *
 * @version $Id: $
 */
public final class BasePdpEngine implements CloseablePdpEngine
{
	private static final String NULL_STD_ENV_ATTRIBUTE_SOURCE_ARG = &quot;Undefined stdEnvAttributeSource arg (source of standard curent-* environment attributes)&quot;;

<span class="nc" id="L75">	private static final IllegalArgumentException NULL_REQUEST_ARGUMENT_EXCEPTION = new IllegalArgumentException(&quot;No input Decision Request&quot;);</span>

	private interface StandardEnvironmentAttributeIssuer
	{
		Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; get();
	}

<span class="nc" id="L82">	private static final StandardEnvironmentAttributeIssuer NULL_STD_ENV_ATTRIBUTE_ISSUER = new StandardEnvironmentAttributeIssuer()</span>
<span class="nc" id="L83">	{</span>

		@Override
		public Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; get()
		{
<span class="nc" id="L88">			return null;</span>
		}
	};

<span class="nc" id="L92">	private static final StandardEnvironmentAttributeIssuer DEFAULT_TZ_BASED_STD_ENV_ATTRIBUTE_ISSUER = new StandardEnvironmentAttributeIssuer()</span>
<span class="nc" id="L93">	{</span>

		@Override
		public Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; get()
		{
			/*
			 * Set the standard current date/time attribute according to XACML core spec:
			 * &quot;This identifier indicates the current time at the context handler. In practice it is the time at which the request context was created.&quot; (ยงB.7). XACML standard (ยง10.2.5) says: &quot;If
			 * values for these attributes are not present in the decision request, then their values MUST be supplied by the context handler&quot;.
			 */
			// current datetime in default timezone
<span class="nc" id="L104">			final DateTimeValue currentDateTimeValue = new DateTimeValue(new GregorianCalendar());</span>
<span class="nc" id="L105">			return HashCollections.&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt;newImmutableMap(</span>
					// current date-time
<span class="nc" id="L107">					StandardEnvironmentAttribute.CURRENT_DATETIME.getFQN(), Bags.singletonAttributeBag(StandardDatatypes.DATETIME, currentDateTimeValue, AttributeSources.PDP),</span>
					// current date
<span class="nc" id="L109">					StandardEnvironmentAttribute.CURRENT_DATE.getFQN(),</span>
<span class="nc" id="L110">					Bags.singletonAttributeBag(StandardDatatypes.DATE, DateValue.getInstance((XMLGregorianCalendar) currentDateTimeValue.getUnderlyingValue().clone()), AttributeSources.PDP),</span>
					// current time
<span class="nc" id="L112">					StandardEnvironmentAttribute.CURRENT_TIME.getFQN(),</span>
<span class="nc" id="L113">					Bags.singletonAttributeBag(StandardDatatypes.TIME, TimeValue.getInstance((XMLGregorianCalendar) currentDateTimeValue.getUnderlyingValue().clone()), AttributeSources.PDP));</span>
		}
	};

	private static class NonIssuedLikeIssuedAttributeHandlingRequestBuilder implements DecisionRequestBuilder&lt;ImmutableDecisionRequest&gt;
	{
		private final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; namedAttributes;
		private final Map&lt;String, XdmNode&gt; extraContentsByCategory;

		private NonIssuedLikeIssuedAttributeHandlingRequestBuilder(final int expectedNumOfAttributeCategories, final int expectedTotalNumOfAttributes)
<span class="nc" id="L123">		{</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">			namedAttributes = expectedTotalNumOfAttributes &lt; 0 ? HashCollections.newUpdatableMap() : HashCollections.newUpdatableMap(expectedTotalNumOfAttributes);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">			extraContentsByCategory = expectedNumOfAttributeCategories &lt; 0 ? HashCollections.newUpdatableMap() : HashCollections.newUpdatableMap(expectedNumOfAttributeCategories);</span>
<span class="nc" id="L126">		}</span>

		@Override
		public Bag&lt;?&gt; putNamedAttributeIfAbsent(final AttributeFqn attributeId, final AttributeBag&lt;?&gt; attributeValues)
		{
<span class="nc" id="L131">			return namedAttributes.putIfAbsent(attributeId, attributeValues);</span>
		}

		@Override
		public final XdmNode putContentIfAbsent(final String category, final XdmNode content)
		{
<span class="nc" id="L137">			return extraContentsByCategory.putIfAbsent(category, content);</span>
		}

		@Override
		public final ImmutableDecisionRequest build(final boolean returnApplicablePolicies)
		{
<span class="nc" id="L143">			return ImmutableDecisionRequest.getInstance(namedAttributes, extraContentsByCategory, returnApplicablePolicies);</span>
		}

		@Override
		public final void reset()
		{
<span class="nc" id="L149">			namedAttributes.clear();</span>
<span class="nc" id="L150">			extraContentsByCategory.clear();</span>
<span class="nc" id="L151">		}</span>
	}

<span class="nc bnc" id="L154" title="All 2 branches missed.">	private static final class IssuedToNonIssuedAttributeCopyingRequestBuilder extends NonIssuedLikeIssuedAttributeHandlingRequestBuilder</span>
	{
		private IssuedToNonIssuedAttributeCopyingRequestBuilder(final int expectedNumOfAttributeCategories, final int expectedTotalNumOfAttributes)
		{
			/*
			 * Since copying attributes with non-null Issuer to equivalent attributes but without Issuer, we'll get at most twice as many attributes as the ones put by the caller
			 */
<span class="nc" id="L161">			super(expectedNumOfAttributeCategories, 2 * expectedTotalNumOfAttributes);</span>
<span class="nc" id="L162">		}</span>

		@Override
		public Bag&lt;?&gt; putNamedAttributeIfAbsent(final AttributeFqn attributeFqn, final AttributeBag&lt;?&gt; attributeValues)
		{
<span class="nc bnc" id="L167" title="All 4 branches missed.">			assert attributeFqn != null;</span>

			/*
			 * Put the non-issued version of the attribute first
			 */
<span class="nc" id="L172">			final AttributeFqn nonAttributeFqn = AttributeFqns.newInstance(attributeFqn.getCategory(), Optional.empty(), attributeFqn.getId());</span>
<span class="nc" id="L173">			super.putNamedAttributeIfAbsent(nonAttributeFqn, attributeValues);</span>
<span class="nc" id="L174">			return super.putNamedAttributeIfAbsent(attributeFqn, attributeValues);</span>
		}
	}

	/**
	 * Individual decision request evaluator
	 *
	 * @version $Id: $
	 */
<span class="nc bnc" id="L183" title="All 2 branches missed.">	private static abstract class IndividualDecisionRequestEvaluator</span>
	{

		private interface RequestAndPdpIssuedNamedAttributesMerger
		{
			/**
			 * Return an updatable map after merging {@code pdpIssuedAttributes} and {@code requestAttributes} or one of each into it, depending on the implementation
			 * 
			 * @param pdpIssuedAttributes
			 * @param requestAttributes
			 * @return updatable map resulting from merger, or null if nothing merged
			 */
			Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; merge(final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes, final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; requestAttributes);
		}

		private static final IndeterminateEvaluationException newReqMissingStdEnvAttrException(final AttributeFqn attrGUID)
		{
<span class="nc" id="L200">			return new IndeterminateEvaluationException(</span>
					&quot;The standard environment attribute ( &quot; + attrGUID
							+ &quot; ) is not present in the REQUEST although at least one of the others is! (PDP standardEnvironmentAttributeSource = REQUEST_ELSE_PDP.)&quot;,
<span class="nc" id="L203">					XacmlStatusCode.MISSING_ATTRIBUTE.value());</span>
		}

<span class="nc" id="L206">		private static final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; STD_ENV_RESET_MAP = HashCollections.&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt;newImmutableMap(</span>
<span class="nc" id="L207">				StandardEnvironmentAttribute.CURRENT_DATETIME.getFQN(),</span>
<span class="nc" id="L208">				Bags.emptyAttributeBag(StandardDatatypes.DATETIME, newReqMissingStdEnvAttrException(StandardEnvironmentAttribute.CURRENT_DATETIME.getFQN())),</span>
<span class="nc" id="L209">				StandardEnvironmentAttribute.CURRENT_DATE.getFQN(),</span>
<span class="nc" id="L210">				Bags.emptyAttributeBag(StandardDatatypes.DATE, newReqMissingStdEnvAttrException(StandardEnvironmentAttribute.CURRENT_DATE.getFQN())),</span>
<span class="nc" id="L211">				StandardEnvironmentAttribute.CURRENT_TIME.getFQN(),</span>
<span class="nc" id="L212">				Bags.emptyAttributeBag(StandardDatatypes.TIME, newReqMissingStdEnvAttrException(StandardEnvironmentAttribute.CURRENT_TIME.getFQN())));</span>

<span class="nc" id="L214">		private static final RequestAndPdpIssuedNamedAttributesMerger REQUEST_OVERRIDES_ATTRIBUTES_MERGER = new RequestAndPdpIssuedNamedAttributesMerger()</span>
<span class="nc" id="L215">		{</span>

			@Override
			public Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; merge(final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes, final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; requestAttributes)
			{
				/*
				 * Request attribute values override PDP issued ones. Do not modify pdpIssuedAttributes directly as this may be used for other requests (Multiple Decision Profile) as well. so we must
				 * not modify it but clone it before individual decision request processing.
				 */
<span class="nc bnc" id="L224" title="All 2 branches missed.">				if (pdpIssuedAttributes == null)</span>
				{
<span class="nc bnc" id="L226" title="All 2 branches missed.">					return requestAttributes == null ? null : HashCollections.newUpdatableMap(requestAttributes);</span>
				}

				// pdpIssuedAttributes != null
<span class="nc bnc" id="L230" title="All 2 branches missed.">				if (requestAttributes == null)</span>
				{
<span class="nc" id="L232">					return HashCollections.newUpdatableMap(pdpIssuedAttributes);</span>
				}
				// requestAttributes != null

				/**
				 * 
				 * XACML standard (ยง10.2.5) says: &quot;If values for these [the standard environment attributes, i.e. current-time, current-date, current-dateTime] attributes are not present in the
				 * decision request, then their values MUST be supplied by the context handler &quot;. In our case, &quot;context handler&quot; means the PDP. In other words, the attribute values come from request
				 * by default, or from the PDP if (and *only if* in this case) they are not set in the request. More precisely, if any of these standard environment attributes is provided in the
				 * request, none of the PDP values is used, even if some policy requires one that is missing from the request. Indeed, this is to avoid such case when the decision request specifies at
				 * least one date/time attribute, e.g. current-time, but not all of them, e.g. not current-dateTime, and the policy requires both the one(s) provided and the one(s) not provided. In
				 * this case, if the PDP provides its own value(s) for the missing attributes (e.g. current-dateTime), this may cause some inconsistencies since we end up having date/time attributes
				 * coming from two different sources/environments (current-time and current-dateTime for instance).
				 */
<span class="nc bnc" id="L246" title="All 4 branches missed.">				if (requestAttributes.containsKey(StandardEnvironmentAttribute.CURRENT_DATETIME.getFQN()) || requestAttributes.containsKey(StandardEnvironmentAttribute.CURRENT_DATE.getFQN())</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">						|| requestAttributes.containsKey(StandardEnvironmentAttribute.CURRENT_TIME.getFQN()))</span>
				{
					/*
					 * Request has at least one standard env attribute -&gt; make sure all PDP values are ignored (overridden by STD_ENV_RESET_MAP no matter whether requestAttributes contains all of them
					 * or not)
					 */
					// mappings in order of increasing priority
<span class="nc" id="L254">					return HashCollections.newUpdatableMap(pdpIssuedAttributes, STD_ENV_RESET_MAP, requestAttributes);</span>
				}

				// mappings in order of increasing priority
<span class="nc" id="L258">				return HashCollections.newUpdatableMap(pdpIssuedAttributes, requestAttributes);</span>
			}

		};

<span class="nc" id="L263">		private static final RequestAndPdpIssuedNamedAttributesMerger PDP_OVERRIDES_ATTRIBUTES_MERGER = new RequestAndPdpIssuedNamedAttributesMerger()</span>
<span class="nc" id="L264">		{</span>

			@Override
			public Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; merge(final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes, final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; requestAttributes)
			{

				// PDP issued attribute values override request attribute values
				/*
				 * Do not modify pdpIssuedAttributes directly as this may be used for other requests (Multiple Decision Profile) as well. so we must not modify it but clone it before individual
				 * decision request processing.
				 */
<span class="nc bnc" id="L275" title="All 2 branches missed.">				if (pdpIssuedAttributes == null)</span>
				{
<span class="nc bnc" id="L277" title="All 2 branches missed.">					return requestAttributes == null ? null : HashCollections.newUpdatableMap(requestAttributes);</span>
				}

				// pdpIssuedAttributes != null
<span class="nc bnc" id="L281" title="All 2 branches missed.">				if (requestAttributes == null)</span>
				{
<span class="nc" id="L283">					return HashCollections.newUpdatableMap(pdpIssuedAttributes);</span>
				}
				// requestAttributes != null

				// mappings of pdpIssuedAttributes have priority
<span class="nc" id="L288">				return HashCollections.newUpdatableMap(requestAttributes, pdpIssuedAttributes);</span>

			}

		};

<span class="nc" id="L294">		private static final RequestAndPdpIssuedNamedAttributesMerger REQUEST_ONLY_ATTRIBUTES_MERGER = new RequestAndPdpIssuedNamedAttributesMerger()</span>
<span class="nc" id="L295">		{</span>

			@Override
			public Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; merge(final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes, final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; requestAttributes)
			{
				// PDP values completely ignored
<span class="nc bnc" id="L301" title="All 2 branches missed.">				return requestAttributes == null ? null : HashCollections.newUpdatableMap(requestAttributes);</span>
			}

		};

		private final RootPolicyEvaluator rootPolicyEvaluator;
		private final RequestAndPdpIssuedNamedAttributesMerger reqAndPdpIssuedAttributesMerger;

		/**
		 * Creates an evaluator
		 *
		 * @param rootPolicyEvaluator
		 *            root policy evaluator that this request evaluator uses to evaluate individual decision request
		 * @param stdEnvAttributeSource
		 *            (mandatory) Defines the source for the standard environment attributes specified in ยง10.2.5: current-time, current-date and current-dateTime. The options are:
		 *            &lt;ul&gt;
		 *            &lt;li&gt;REQUEST_ELSE_PDP: the default choice, that complies with the XACML standard (ยง10.2.5): &quot;If values for these attributes are not present in the decision request, then their
		 *            values MUST be supplied by the context handler&quot;, in our case, &quot; context handler&quot; means the PDP. In other words, the attribute values come from request by default, or from the PDP
		 *            if (and *only if* in this case) they are not set in the request. Issue: what if the decision request only specifies current-time but not current-dateTime, and the policy requires
		 *            both? Should the PDP provides its own value for current-dateTime? This could cause some inconsistencies since current-time and current-dateTime would come from two different
		 *            sources/environments. With this option, we have a strict interpretation of the spec, i.e. if any of these attribute is not set in the request, the PDP uses its own value instead.
		 *            So BEWARE. Else you have the other options below.&lt;/li&gt;
		 *            &lt;li&gt;REQUEST_ONLY: always use the standard environment attribute value from the request, or nothing if the value is not set in the request, in which case this results in
		 *            Indeterminate (missing attribute) if the policy evaluation requires it.&lt;/li&gt;
		 *            &lt;li&gt;PDP_ONLY: always use the standard environment attribute values from the PDP. In other words, Request values are simply ignored; PDP values for standard environment attributes
		 *            systematically override the ones from the request. This also guarantees that they are always set (by the PDP). NB: note that the XACML standard (ยง10.2.5) says: &quot;If values for
		 *            these attributes are not present in the decision request, then their values MUST be supplied by the context handler &quot; but it does NOT say &quot;If AND ONLY IF values...&quot; So this
		 *            option could still be considered XACML compliant in a strict sense.&lt;/li&gt;
		 *            &lt;/ul&gt;
		 * @throws IllegalArgumentException
		 *             if {@code stdEnvAttributeSource} is null or not supported
		 */
		protected IndividualDecisionRequestEvaluator(final RootPolicyEvaluator rootPolicyEvaluator, final StandardEnvironmentAttributeSource stdEnvAttributeSource) throws IllegalArgumentException
<span class="nc" id="L334">		{</span>
<span class="nc bnc" id="L335" title="All 6 branches missed.">			assert rootPolicyEvaluator != null &amp;&amp; stdEnvAttributeSource != null;</span>
<span class="nc" id="L336">			this.rootPolicyEvaluator = rootPolicyEvaluator;</span>
<span class="nc bnc" id="L337" title="All 4 branches missed.">			switch (stdEnvAttributeSource)</span>
			{
				case PDP_ONLY:
					/*
					 * PDP_ONLY means the standard environment attribute values come from the PDP only (not the Request), this does not affect other attributes. In other words, only PDP's standard
					 * environment attribute values override.
					 */
<span class="nc" id="L344">					this.reqAndPdpIssuedAttributesMerger = PDP_OVERRIDES_ATTRIBUTES_MERGER;</span>
<span class="nc" id="L345">					break;</span>
				case REQUEST_ONLY:
<span class="nc" id="L347">					this.reqAndPdpIssuedAttributesMerger = REQUEST_ONLY_ATTRIBUTES_MERGER;</span>
<span class="nc" id="L348">					break;</span>
				case REQUEST_ELSE_PDP:
<span class="nc" id="L350">					this.reqAndPdpIssuedAttributesMerger = REQUEST_OVERRIDES_ATTRIBUTES_MERGER;</span>
<span class="nc" id="L351">					break;</span>
				default:
<span class="nc" id="L353">					throw new IllegalArgumentException(</span>
<span class="nc" id="L354">							&quot;Unsupported standardEnvAttributeSource: &quot; + stdEnvAttributeSource + &quot;. Expected: &quot; + Arrays.toString(StandardEnvironmentAttributeSource.values()));</span>
			}
<span class="nc" id="L356">		}</span>

		protected final EvaluationContext newEvaluationContext(final DecisionRequest request, final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes)
		{
<span class="nc bnc" id="L360" title="All 4 branches missed.">			assert request != null;</span>
<span class="nc" id="L361">			final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; mergedNamedAttributes = reqAndPdpIssuedAttributesMerger.merge(pdpIssuedAttributes, request.getNamedAttributes());</span>
<span class="nc" id="L362">			return new IndividualDecisionRequestContext(mergedNamedAttributes, request.getExtraContentsByCategory(), request.isApplicablePolicyIdListReturned());</span>
		}

		protected final DecisionResult evaluateInNewContext(final DecisionRequest request, final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes)
		{
<span class="nc bnc" id="L367" title="All 4 branches missed.">			assert request != null;</span>
<span class="nc" id="L368">			final EvaluationContext evalCtx = newEvaluationContext(request, pdpIssuedAttributes);</span>
<span class="nc" id="L369">			return rootPolicyEvaluator.findAndEvaluate(evalCtx);</span>
		}

		/**
		 * &lt;p&gt;
		 * Evaluate Individual Decision Request in an existing request context
		 * &lt;/p&gt;
		 *
		 * @param evalCtx
		 *            existing evaluation context
		 * @return the evaluation result.
		 */
		protected final DecisionResult evaluateReusingContext(final EvaluationContext evalCtx)
		{
<span class="nc" id="L383">			return rootPolicyEvaluator.findAndEvaluate(evalCtx);</span>
		}

		/**
		 * &lt;p&gt;
		 * Evaluate an Individual Decision Request from which a new request context is created to evaluate the request
		 * &lt;/p&gt;
		 *
		 * @param individualDecisionRequest
		 *            a non-null {@link DecisionRequest} object, i.e. representation of Individual Decision Request (as defined by Multiple Decision Profile of XACML).
		 * @param pdpIssuedAttributes
		 *            a {@link java.util.Map} of PDP-issued attributes including at least the standard environment attributes: current-time, current-date, current-dateTime.
		 * @return the evaluation result.
		 */
		protected abstract DecisionResult evaluate(final DecisionRequest individualDecisionRequest, final StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer);

		/**
		 * &lt;p&gt;
		 * Evaluate multiple Individual Decision Requests with same PDP-issued attribute values (e.g. current date/time) in order to return decision results in internal model.
		 * &lt;/p&gt;
		 *
		 * @param individualDecisionRequests
		 *            a {@link java.util.List} of individual decision requests.
		 * @param pdpStdEnvAttributeIssuer
		 *            a {@link java.util.Map} of PDP-issued attributes including at least the standard environment attributes: current-time, current-date, current-dateTime.
		 * @return individual decision request-result pairs, where the list of the requests is the same as {@code individualDecisionRequests}.
		 * @throws IndeterminateEvaluationException
		 *             if an error occurred preventing any request evaluation
		 */
		protected abstract &lt;INDIVIDUAL_DECISION_REQ_T extends DecisionRequest&gt; Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; evaluate(
				List&lt;INDIVIDUAL_DECISION_REQ_T&gt; individualDecisionRequests, final StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer) throws IndeterminateEvaluationException;

	}

<span class="nc bnc" id="L417" title="All 2 branches missed.">	private static final class NonCachingIndividualDecisionRequestEvaluator extends IndividualDecisionRequestEvaluator</span>
	{
<span class="nc" id="L419">		private static final Logger LOGGER = LoggerFactory.getLogger(NonCachingIndividualDecisionRequestEvaluator.class);</span>

<span class="nc" id="L421">		private static final RuntimeException NULL_INDIVIDUAL_DECISION_REQUEST_EXCEPTION = new RuntimeException(</span>
				&quot;One of the individual decision requests returned by the request filter is invalid (null).&quot;);

		private NonCachingIndividualDecisionRequestEvaluator(final RootPolicyEvaluator rootPolicyEvaluator, final StandardEnvironmentAttributeSource stdEnvAttributeSource)
		{
<span class="nc" id="L426">			super(rootPolicyEvaluator, stdEnvAttributeSource);</span>
<span class="nc" id="L427">		}</span>

		@Override
		protected DecisionResult evaluate(DecisionRequest request, StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer)
		{
<span class="nc bnc" id="L432" title="All 4 branches missed.">			assert request != null;</span>
<span class="nc" id="L433">			LOGGER.debug(&quot;Evaluating Individual Decision Request: {}&quot;, request);</span>
<span class="nc" id="L434">			return evaluateInNewContext(request, pdpStdEnvAttributeIssuer.get());</span>
		}

		@Override
		protected &lt;INDIVIDUAL_DECISION_REQ_T extends DecisionRequest&gt; Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; evaluate(
				final List&lt;INDIVIDUAL_DECISION_REQ_T&gt; individualDecisionRequests, final StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer) throws IndeterminateEvaluationException
		{
<span class="nc bnc" id="L441" title="All 6 branches missed.">			assert individualDecisionRequests != null &amp;&amp; pdpStdEnvAttributeIssuer != null;</span>

<span class="nc" id="L443">			final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes = pdpStdEnvAttributeIssuer.get();</span>
<span class="nc" id="L444">			final Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; resultsByRequest = new ArrayDeque&lt;&gt;(individualDecisionRequests.size());</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">			for (final INDIVIDUAL_DECISION_REQ_T individualDecisionRequest : individualDecisionRequests)</span>
			{
<span class="nc bnc" id="L447" title="All 2 branches missed.">				if (individualDecisionRequest == null)</span>
				{
<span class="nc" id="L449">					throw NULL_INDIVIDUAL_DECISION_REQUEST_EXCEPTION;</span>
				}

<span class="nc" id="L452">				final DecisionResult decisionResult = evaluateInNewContext(individualDecisionRequest, pdpIssuedAttributes);</span>
<span class="nc" id="L453">				resultsByRequest.add(new SimpleImmutableEntry&lt;&gt;(individualDecisionRequest, decisionResult));</span>
<span class="nc" id="L454">			}</span>

<span class="nc" id="L456">			return resultsByRequest;</span>
		}

	}

<span class="nc bnc" id="L461" title="All 2 branches missed.">	private static final class IndividualRequestEvaluatorWithCacheIgnoringEvaluationContext extends IndividualDecisionRequestEvaluator</span>
	{
<span class="nc" id="L463">		private static final Logger LOGGER = LoggerFactory.getLogger(IndividualRequestEvaluatorWithCacheIgnoringEvaluationContext.class);</span>

<span class="nc" id="L465">		private static final IndeterminateEvaluationException INDETERMINATE_EVALUATION_EXCEPTION = new IndeterminateEvaluationException(&quot;Internal error in decision cache: null result&quot;,</span>
<span class="nc" id="L466">				XacmlStatusCode.PROCESSING_ERROR.value());</span>

		private final DecisionCache decisionCache;

		private IndividualRequestEvaluatorWithCacheIgnoringEvaluationContext(final RootPolicyEvaluator rootPolicyEvaluator, final StandardEnvironmentAttributeSource stdEnvAttributeSource,
				final DecisionCache decisionCache)
		{
<span class="nc" id="L473">			super(rootPolicyEvaluator, stdEnvAttributeSource);</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">			assert decisionCache != null;</span>
<span class="nc" id="L475">			this.decisionCache = decisionCache;</span>
<span class="nc" id="L476">		}</span>

		@Override
		protected DecisionResult evaluate(DecisionRequest individualDecisionRequest, StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer)
		{
<span class="nc bnc" id="L481" title="All 4 branches missed.">			assert individualDecisionRequest != null;</span>
<span class="nc" id="L482">			LOGGER.debug(&quot;Evaluating Individual Decision Request: {}&quot;, individualDecisionRequest);</span>
<span class="nc" id="L483">			final DecisionResult cachedResult = decisionCache.get(individualDecisionRequest, null);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">			if (cachedResult == null)</span>
			{
<span class="nc" id="L486">				LOGGER.debug(&quot;No result found in cache for Individual Decision Request: {}. Computing new result from policy evaluation...&quot;, individualDecisionRequest);</span>
<span class="nc" id="L487">				final DecisionResult newResult = evaluateInNewContext(individualDecisionRequest, pdpStdEnvAttributeIssuer.get());</span>
<span class="nc" id="L488">				LOGGER.debug(&quot;Caching new Result for Individual Decision Request: {} -&gt; {}&quot;, individualDecisionRequest, newResult);</span>
<span class="nc" id="L489">				decisionCache.put(individualDecisionRequest, newResult, null);</span>
<span class="nc" id="L490">				return newResult;</span>
			}

<span class="nc" id="L493">			LOGGER.debug(&quot;Result found in cache for Individual Decision Request: {} -&gt; {}&quot;, individualDecisionRequest, cachedResult);</span>
<span class="nc" id="L494">			return cachedResult;</span>
		}

		@Override
		protected &lt;INDIVIDUAL_DECISION_REQ_T extends DecisionRequest&gt; Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; evaluate(
				final List&lt;INDIVIDUAL_DECISION_REQ_T&gt; individualDecisionRequests, final StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer) throws IndeterminateEvaluationException
		{
<span class="nc bnc" id="L501" title="All 6 branches missed.">			assert individualDecisionRequests != null &amp;&amp; pdpStdEnvAttributeIssuer != null;</span>

<span class="nc" id="L503">			final Map&lt;INDIVIDUAL_DECISION_REQ_T, DecisionResult&gt; cachedResultsByRequest = decisionCache.getAll(individualDecisionRequests);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">			if (cachedResultsByRequest == null)</span>
			{
				// error, return indeterminate result as only result
<span class="nc" id="L507">				LOGGER.error(&quot;Invalid decision cache result: null&quot;);</span>
<span class="nc" id="L508">				throw INDETERMINATE_EVALUATION_EXCEPTION;</span>
			}

<span class="nc" id="L511">			final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes = pdpStdEnvAttributeIssuer.get();</span>
			/*
			 * There will be at most as many new results (not in cache) as there are individual decision requests
			 */
<span class="nc" id="L515">			final Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; finalResultsByRequest = new ArrayDeque&lt;&gt;(individualDecisionRequests.size());</span>
<span class="nc" id="L516">			final Map&lt;INDIVIDUAL_DECISION_REQ_T, DecisionResult&gt; newResultsByRequest = HashCollections.newUpdatableMap(individualDecisionRequests.size());</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">			for (final INDIVIDUAL_DECISION_REQ_T individualDecisionRequest : individualDecisionRequests)</span>
			{
<span class="nc" id="L519">				LOGGER.debug(&quot;Evaluating Individual Decision Request: {}&quot;, individualDecisionRequest);</span>
				final DecisionResult finalResult;
				/*
				 * Check whether there is any decision result in cache for this request
				 */
<span class="nc" id="L524">				final DecisionResult cachedResult = cachedResultsByRequest.get(individualDecisionRequest);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">				if (cachedResult == null)</span>
				{
<span class="nc" id="L527">					LOGGER.debug(&quot;No result found in cache for Individual Decision Request: {}. Computing new result from policy evaluation...&quot;, individualDecisionRequest);</span>
<span class="nc" id="L528">					finalResult = evaluateInNewContext(individualDecisionRequest, pdpIssuedAttributes);</span>
<span class="nc" id="L529">					LOGGER.debug(&quot;Caching new Result for Individual Decision Request: {} -&gt; {}&quot;, individualDecisionRequest, finalResult);</span>
<span class="nc" id="L530">					newResultsByRequest.put(individualDecisionRequest, finalResult);</span>
				}
				else
				{

<span class="nc" id="L535">					LOGGER.debug(&quot;Result found in cache for Individual Decision Request: {} -&gt; {}&quot;, individualDecisionRequest, cachedResult);</span>
<span class="nc" id="L536">					finalResult = cachedResult;</span>
				}

<span class="nc" id="L539">				finalResultsByRequest.add(new SimpleImmutableEntry&lt;&gt;(individualDecisionRequest, finalResult));</span>
<span class="nc" id="L540">			}</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">			if (!newResultsByRequest.isEmpty())</span>
			{
<span class="nc" id="L544">				decisionCache.putAll(newResultsByRequest);</span>
			}

<span class="nc" id="L547">			return finalResultsByRequest;</span>
		}

	}

<span class="nc bnc" id="L552" title="All 2 branches missed.">	private static final class IndividualRequestEvaluatorWithCacheUsingEvaluationContext extends IndividualDecisionRequestEvaluator</span>
	{
<span class="nc" id="L554">		private static final Logger LOGGER = LoggerFactory.getLogger(IndividualRequestEvaluatorWithCacheUsingEvaluationContext.class);</span>

		private final DecisionCache decisionCache;

		private IndividualRequestEvaluatorWithCacheUsingEvaluationContext(final RootPolicyEvaluator rootPolicyEvaluator, final StandardEnvironmentAttributeSource validStdEnvAttrSrc,
				final DecisionCache decisionCache)
		{
<span class="nc" id="L561">			super(rootPolicyEvaluator, validStdEnvAttrSrc);</span>
<span class="nc bnc" id="L562" title="All 4 branches missed.">			assert decisionCache != null;</span>
<span class="nc" id="L563">			this.decisionCache = decisionCache;</span>
<span class="nc" id="L564">		}</span>

		private &lt;INDIVIDUAL_DECISION_REQ_T extends DecisionRequest&gt; DecisionResult evaluate(final INDIVIDUAL_DECISION_REQ_T individualDecisionRequest,
				final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes)
		{
<span class="nc bnc" id="L569" title="All 4 branches missed.">			assert individualDecisionRequest != null;</span>
<span class="nc" id="L570">			LOGGER.debug(&quot;Evaluating Individual Decision Request: {}&quot;, individualDecisionRequest);</span>
			/*
			 * Check whether there is any decision result in cache for this request
			 */
<span class="nc" id="L574">			final EvaluationContext evalCtx = newEvaluationContext(individualDecisionRequest, pdpIssuedAttributes);</span>
<span class="nc" id="L575">			final DecisionResult cachedResult = decisionCache.get(individualDecisionRequest, evalCtx);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">			if (cachedResult == null)</span>
			{
<span class="nc" id="L578">				LOGGER.debug(&quot;No result found in cache for Individual Decision Request: {}. Computing new result from policy evaluation...&quot;, individualDecisionRequest);</span>
<span class="nc" id="L579">				final DecisionResult finalResult = evaluateReusingContext(evalCtx);</span>
<span class="nc" id="L580">				LOGGER.debug(&quot;Caching new Result for Individual Decision Request: {} -&gt; {}&quot;, individualDecisionRequest, finalResult);</span>
<span class="nc" id="L581">				decisionCache.put(individualDecisionRequest, finalResult, evalCtx);</span>
<span class="nc" id="L582">				return finalResult;</span>
			}

<span class="nc" id="L585">			LOGGER.debug(&quot;Result found in cache for Individual Decision Request: {} -&gt; {}&quot;, individualDecisionRequest, cachedResult);</span>
<span class="nc" id="L586">			return cachedResult;</span>
		}

		@Override
		protected DecisionResult evaluate(DecisionRequest individualDecisionRequest, StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer)
		{
<span class="nc bnc" id="L592" title="All 6 branches missed.">			assert individualDecisionRequest != null &amp;&amp; pdpStdEnvAttributeIssuer != null;</span>
<span class="nc" id="L593">			return evaluate(individualDecisionRequest, pdpStdEnvAttributeIssuer.get());</span>
		}

		@Override
		protected &lt;INDIVIDUAL_DECISION_REQ_T extends DecisionRequest&gt; Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; evaluate(
				final List&lt;INDIVIDUAL_DECISION_REQ_T&gt; individualDecisionRequests, final StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer) throws IndeterminateEvaluationException
		{
<span class="nc bnc" id="L600" title="All 6 branches missed.">			assert individualDecisionRequests != null &amp;&amp; pdpStdEnvAttributeIssuer != null;</span>

<span class="nc" id="L602">			final Map&lt;AttributeFqn, AttributeBag&lt;?&gt;&gt; pdpIssuedAttributes = pdpStdEnvAttributeIssuer.get();</span>
			/*
			 * There will be at most as many new results (not in cache) as there are individual decision requests
			 */
<span class="nc" id="L606">			final Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; finalResultsByRequest = new ArrayDeque&lt;&gt;(individualDecisionRequests.size());</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">			for (final INDIVIDUAL_DECISION_REQ_T individualDecisionRequest : individualDecisionRequests)</span>
			{
<span class="nc" id="L609">				final DecisionResult finalResult = evaluate(individualDecisionRequest, pdpIssuedAttributes);</span>
<span class="nc" id="L610">				finalResultsByRequest.add(new SimpleImmutableEntry&lt;&gt;(individualDecisionRequest, finalResult));</span>
<span class="nc" id="L611">			}</span>

<span class="nc" id="L613">			return finalResultsByRequest;</span>
		}

	}

	private final boolean strictAttributeIssuerMatch;
	private final IndividualDecisionRequestEvaluator individualReqEvaluator;
	private final DecisionCache decisionCache;
	private final RootPolicyEvaluator rootPolicyEvaluator;
	private final StandardEnvironmentAttributeIssuer pdpStdEnvAttributeIssuer;

	/**
	 * Constructs a new PDP engine with the given configuration information.
	 *
	 * @param xacmlExpressionFactory
	 *            XACML Expression parser/factory - mandatory
	 * @param rootPolicyProvider
	 *            Root Policy Provider - mandatory
	 * @param decisionCache
	 *            (optional) decision response cache
	 * @param strictAttributeIssuerMatch
	 *            true iff strict Attribute Issuer matching is enabled, i.e. AttributeDesignators without Issuer only match request Attributes without Issuer (and same AttributeId, Category...). This
	 *            mode is not fully compliant with XACML 3.0, ยง5.29, in the case that the Issuer is indeed not present on a AttributeDesignator; but it performs better and is recommended when all
	 *            AttributeDesignators have an Issuer (best practice). Reminder: the XACML 3.0 specification for AttributeDesignator evaluation (5.29) says: &quot;If the Issuer is not present in the
	 *            attribute designator, then the matching of the attribute to the named attribute SHALL be governed by AttributeId and DataType attributes alone.&quot;
	 * @param stdEnvAttributeSource
	 *            (mandatory) source for standard environment current-time/current-date/current-dateTime attribute values (request or PDP, etc.).
	 * @throws java.lang.IllegalArgumentException
	 *             if one of the mandatory arguments is null ({@code xacmlExpressionFactory}, {@code rootPolicyProvider})
	 * @throws java.io.IOException
	 *             error closing the root policy Provider when static resolution is to be used
	 */
	public BasePdpEngine(final ExpressionFactory xacmlExpressionFactory, final RootPolicyProvider rootPolicyProvider, final boolean strictAttributeIssuerMatch,
			final StandardEnvironmentAttributeSource stdEnvAttributeSource, final Optional&lt;DecisionCache&gt; decisionCache) throws IllegalArgumentException, IOException
<span class="nc" id="L647">	{</span>
<span class="nc" id="L648">		final RootPolicyEvaluators.Base candidateRootPolicyEvaluator = new RootPolicyEvaluators.Base(xacmlExpressionFactory, rootPolicyProvider);</span>
		// Use static resolution if possible
<span class="nc" id="L650">		final RootPolicyEvaluator staticRootPolicyEvaluator = candidateRootPolicyEvaluator.toStatic();</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">		if (staticRootPolicyEvaluator == null)</span>
		{
<span class="nc" id="L653">			this.rootPolicyEvaluator = candidateRootPolicyEvaluator;</span>
		}
		else
		{
<span class="nc" id="L657">			this.rootPolicyEvaluator = staticRootPolicyEvaluator;</span>
		}

<span class="nc" id="L660">		this.strictAttributeIssuerMatch = strictAttributeIssuerMatch;</span>

<span class="nc" id="L662">		Preconditions.checkNotNull(stdEnvAttributeSource, NULL_STD_ENV_ATTRIBUTE_SOURCE_ARG);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">		this.pdpStdEnvAttributeIssuer = stdEnvAttributeSource == StandardEnvironmentAttributeSource.REQUEST_ONLY ? NULL_STD_ENV_ATTRIBUTE_ISSUER : DEFAULT_TZ_BASED_STD_ENV_ATTRIBUTE_ISSUER;</span>

<span class="nc" id="L665">		this.decisionCache = decisionCache.orElse(null);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">		if (this.decisionCache == null)</span>
		{
<span class="nc" id="L668">			this.individualReqEvaluator = new NonCachingIndividualDecisionRequestEvaluator(rootPolicyEvaluator, stdEnvAttributeSource);</span>
		}
		else
		{
<span class="nc bnc" id="L672" title="All 2 branches missed.">			this.individualReqEvaluator = this.decisionCache.isEvaluationContextRequired()</span>
					? new IndividualRequestEvaluatorWithCacheUsingEvaluationContext(rootPolicyEvaluator, stdEnvAttributeSource, this.decisionCache)
					: new IndividualRequestEvaluatorWithCacheIgnoringEvaluationContext(rootPolicyEvaluator, stdEnvAttributeSource, this.decisionCache);
		}
<span class="nc" id="L676">	}</span>

	/**
	 * Constructs a new PDP engine with the given configuration information.
	 *
	 * @param configuration
	 *            PDP engine configuration
	 *
	 * @throws java.lang.IllegalArgumentException
	 *             if {@code configuration.getXacmlExpressionFactory() == null || configuration.getRootPolicyProvider() == null}
	 * @throws java.io.IOException
	 *             error closing {@code configuration.getRootPolicyProvider()} when static resolution is to be used
	 */
	public BasePdpEngine(final PdpEngineConfiguration configuration) throws IllegalArgumentException, IOException
	{
<span class="nc" id="L691">		this(configuration.getXacmlExpressionFactory(), configuration.getRootPolicyProvider(), configuration.isStrictAttributeIssuerMatchEnabled(), configuration.getStdEnvAttributeSource(),</span>
<span class="nc" id="L692">				configuration.getDecisionCache());</span>
<span class="nc" id="L693">	}</span>

	@Override
	public Iterable&lt;PrimaryPolicyMetadata&gt; getApplicablePolicies()
	{
<span class="nc" id="L698">		return this.rootPolicyEvaluator.getStaticApplicablePolicies();</span>
	}

	@Override
	public DecisionRequestBuilder&lt;?&gt; newRequestBuilder(final int expectedNumOfAttributeCategories, final int expectedTotalNumOfAttributes)
	{
<span class="nc bnc" id="L704" title="All 2 branches missed.">		return this.strictAttributeIssuerMatch ? new NonIssuedLikeIssuedAttributeHandlingRequestBuilder(expectedNumOfAttributeCategories, expectedTotalNumOfAttributes)</span>
				: new IssuedToNonIssuedAttributeCopyingRequestBuilder(expectedNumOfAttributeCategories, expectedTotalNumOfAttributes);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public DecisionResult evaluate(final DecisionRequest individualDecisionRequest)
	{
<span class="nc bnc" id="L714" title="All 2 branches missed.">		if (individualDecisionRequest == null)</span>
		{
<span class="nc" id="L716">			throw NULL_REQUEST_ARGUMENT_EXCEPTION;</span>
		}

		/*
		 * Evaluate the individual decision request with extra common attributes set by the PDP once for all: standard environment attributes, i.e. current-time, etc. XACML standard (ยง10.2.5) says:
		 * &quot;If values for these attributes are not present in the decision request, then their values MUST be supplied by the context handler&quot; . These current date/time values must be set here once
		 * before an individual request is evaluated to make sure it uses the same value for current-time/current-date/current-dateTime during the entire evaluation, if they use the one from PDP.
		 */
<span class="nc" id="L724">		return individualReqEvaluator.evaluate(individualDecisionRequest, this.pdpStdEnvAttributeIssuer);</span>
	}

	/** {@inheritDoc} */
	@Override
	public &lt;INDIVIDUAL_DECISION_REQ_T extends DecisionRequest&gt; Collection&lt;Entry&lt;INDIVIDUAL_DECISION_REQ_T, ? extends DecisionResult&gt;&gt; evaluate(
			final List&lt;INDIVIDUAL_DECISION_REQ_T&gt; individualDecisionRequests) throws IndeterminateEvaluationException
	{
<span class="nc bnc" id="L732" title="All 2 branches missed.">		if (individualDecisionRequests == null)</span>
		{
<span class="nc" id="L734">			throw NULL_REQUEST_ARGUMENT_EXCEPTION;</span>
		}

		/*
		 * Evaluate the individual decision requests with extra common attributes set by the PDP once for all: standard environment attributes, i.e. current-time, etc. XACML standard (ยง10.2.5) says:
		 * &quot;If values for these attributes are not present in the decision request, then their values MUST be supplied by the context handler&quot; . These current date/time values must be set here once
		 * before every individual request is evaluated to make sure they all use the same value for current-time/current-date/current-dateTime, if they use the one from PDP.
		 */
<span class="nc" id="L742">		return individualReqEvaluator.evaluate(individualDecisionRequests, this.pdpStdEnvAttributeIssuer);</span>
	}

	/** {@inheritDoc} */
	@Override
	public void close() throws IOException
	{
<span class="nc" id="L749">		rootPolicyEvaluator.close();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">		if (decisionCache != null)</span>
		{
<span class="nc" id="L752">			decisionCache.close();</span>
		}
<span class="nc" id="L754">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>